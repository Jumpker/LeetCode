#include <stdio.h>
#include <stdlib.h>

int uniquePaths(int m, int n) {
    if(m==1 && n==1) return 1;

    /*
    经典动态规划问题

    1. 思考每轮决策定义状态，得到dp表：
    每轮决策为往下或往右走，利用a[i][j]获得坐标索引，每轮决策为a[i+1][j](往下)或a[i][j+1](往右)
    状态[i,j]对应子问题为走到[i,j]有dp[i][j]条路径(即dp表为走到[i,j]有dp[i][j]条路径)

    2. 找出最优子结构，推导出状态转移方程
    移动到某一点，由于只能从该点上方或左方移到，移动到该点路径数为左边加上边格子的路径数，即状态转移方程
    dp[i,j] = dp[i-1][j](上方转移过来) + dp[i][j-1](左方转移过来)

    3. 确定边界条件和状态转移顺序
    首行状态只能从其左边转移而来，首列状态只能从其上方转移过来，则边界条件首行首列状态均为1; 另外边界条件dp[i][j]=0
    并且别忘了i<m, j<n
    */

    int dp[m][n];                                       //初始化dp表
    dp[0][0] = 0;

    for(int j=1; j<n; j++){                             //首行的状态转移方程
        dp[0][j] = 1;
    }

    for(int i=1; i<m; i++){                             //首列的状态转移方程
        dp[i][0] = 1;
    }

    for(int j=1; j<n; j++){                             //其余格子的状态转移方程
        for(int i=1; i<m; i++){
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }

    return dp[m-1][n-1];
}